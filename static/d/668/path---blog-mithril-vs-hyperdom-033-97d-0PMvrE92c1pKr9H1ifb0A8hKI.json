{"data":{"markdownRemark":{"html":"<p><a href=\"https://mithril.js.org/\">Mithril</a> is a ‚ÄúA modern client-side Javascript framework for building Single Page Applications‚Äù. So are many other frameworks out there. So is my personal favorite - <a href=\"http://hyperdom.org/\">Hyperdom</a>. What sets Mithril apart from the some other frameworks that I looked into is just how similar it is to Hyperdom in terms of development experience.</p>\n<p>This is because they both operate under these two fundamental assumptions: ‚Äúcomponent instances are <em>not</em> recreated on each render‚Äù and ‚Äúautomatically redraw everything on some common events‚Äù.</p>\n<p>In practice, that means that there is no reason for the framework to manage application state. State can be simply stored in plain javascript objects that have nothing to do with the framework. If you‚Äôre familiar with React, imagine you could write <code class=\"language-text\">state.foo = &#39;bar&#39;</code> (<code class=\"language-text\">state</code> being a regular javascript object) instead of <code class=\"language-text\">this.setState({foo: &#39;bar&#39;})</code> and <code class=\"language-text\">bar</code> will still show up in the DOM. Even if <code class=\"language-text\">state.foo</code> is referenced from other components, they will all pick up the change and update their views.</p>\n<p>In other words, both Mithril and Hyperdom satisfy the ultimate state management requirement:</p>\n<blockquote class=\"twitter-tweet\" data-lang=\"en\"><p lang=\"en\" dir=\"ltr\">my js state management library: {}</p>&mdash; TJ Holowaychuk üôÉ (@tjholowaychuk) <a href=\"https://twitter.com/tjholowaychuk/status/957853652483416064?ref_src=twsrc%5Etfw\">January 29, 2018</a></blockquote>\n<br/>\n<br/>\n<p>To get a real taste for it, I made a small app in both technologies and they look strikingly similar. You can play with both of them on codesandbox: <a href=\"https://codesandbox.io/s/beer-app-mithril-cy0z6\">mithril beer app</a> and <a href=\"https://codesandbox.io/s/beer-app-hyperdom-phbf5\">hyperdom beer app</a></p>\n<p>The project, albeit small, covers the following key points:</p>\n<ul>\n<li>routing</li>\n<li>state</li>\n<li>xhr</li>\n<li>input binding</li>\n<li>layout</li>\n<li>components composition</li>\n</ul>\n<p>As mentioned above, the result was similar, but there were of course differences and the rest of this post will go over those that I managed to spot.</p>\n<p><em>Disclaimer: I know Hyperdom reasonably well but I was using Mithril for the first time. It‚Äôs possible that some of the comparison below is unfair/incorrect.</em></p>\n<h2>Automatic redrawing</h2>\n<p>As mentioned above, both Hyperdom and Mithril feature automatic rerender of the entire component tree after certain common events. These are:</p>\n<ul>\n<li>bound input change</li>\n<li>onclick event handler</li>\n<li>navigation</li>\n<li>xhr response</li>\n</ul>\n<p>While first three work identically in both frameworks, the last one differs a bit.</p>\n<p>Hyperdom doesn‚Äôt actually do anything special on xhr, it simply triggers another render if an event handler happens to return a promise. So long as you‚Äôre using a promise based http client (or fetch api), it will naturally redraw after request is finished.</p>\n<p>Mithril doesn‚Äôt have this special treatment of promises, instead it provides its own http client. Beside the ‚ÄúI have to learn the Mithril way of making xhr requests‚Äù, there are couple of other problems here. Consider this code:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">  <span class=\"token function\">oninit</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">vnode</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    m<span class=\"token punctuation\">.</span><span class=\"token function\">request</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      method<span class=\"token punctuation\">:</span> <span class=\"token string\">'GET'</span><span class=\"token punctuation\">,</span>\n      url<span class=\"token punctuation\">:</span> <span class=\"token string\">\"https://api.punkapi.com/v2/beers\"</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">data</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>beers <span class=\"token operator\">=</span> data\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>Mithril is going to render again after <code class=\"language-text\">then</code> is executed.</p>\n<p>It‚Äôs 2019, the immediate urge is to rewrite that code using async/await:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">  <span class=\"token keyword\">async</span> <span class=\"token function\">oninit</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">vnode</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>beers <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> m<span class=\"token punctuation\">.</span><span class=\"token function\">request</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      method<span class=\"token punctuation\">:</span> <span class=\"token string\">'GET'</span><span class=\"token punctuation\">,</span>\n      url<span class=\"token punctuation\">:</span> <span class=\"token string\">\"https://api.punkapi.com/v2/beers\"</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>But, alas, that does not work. I don‚Äôt know why.</p>\n<p>Another thing with the custom http client: what if I am not using Rest API? What about Graphql? I didn‚Äôt find any Mithril Graphql clients that hook into autoredraw. Of course one can always call <code class=\"language-text\">m.redraw()</code> manually, but that‚Äôs not ideal.</p>\n<h3>Opting out of Autoredraw</h3>\n<p>Both Mithril and Hyperdom allow components to opt out of autoredraw framework. Mithril way is to mount component using <code class=\"language-text\">m.render</code> rather than <code class=\"language-text\">m.mount</code>/<code class=\"language-text\">m.route</code>. Since only top level component/routes are mounted, it was not clear to me how to opt out of autoredraw in some leaf component.</p>\n<p>Hyperdom requires you to return <code class=\"language-text\">hyperdom.norefresh()</code> from an event handler to signal the opt out, so cancelling autoredraw on a case by case basis seems straightforward. There is also caching and the ability to take over the entire redraw control with <code class=\"language-text\">refreshify</code>.</p>\n<h2>Routing</h2>\n<p>Mithril routes are defined at the time the application is mounted. As a result all routes are listed in one place which is nice. Hyperdom on the other hand allows each component to specify which routes it wants to handle (the example projects reflects this well). This makes it harder to see ‚Äúrouting table‚Äù at a glance. I guess I‚Äôd prefer if it was more like Mithril (however, I haven‚Äôt used it in anger - there may be implications/restrictions that are not obvious from where I stand).</p>\n<h3>Links</h3>\n<p>Hyperdom intercepts any link and checks if it matches any route. Mithril requires you to explicitly turn a link into the one handled by router. I prefer the Hyperdom way - it‚Äôs just one less thing to remember.</p>\n<h3>URL params binding</h3>\n<p>Hyperdom allows to bind URL query params onto the state much like an input binding. E.g., a user types into an input and the framework renders it in the DOM <em>and</em> in the URL. I haven‚Äôt found a way to achieve that in Mithril.</p>\n<h3>In-memory router</h3>\n<p>Hyperdom comes with an in-memory router implementation that can be used in tests. I haven‚Äôt found a similar thing in Mithril.</p>\n<h2>Components composition</h2>\n<p>Hyperdom does not impose any frameworky stuff onto how components are instantiated. Any javascript object with <code class=\"language-text\">render</code>/<code class=\"language-text\">routes</code> method can act as one. So creating components is no different from any other javascript object - just call a <code class=\"language-text\">new</code> on a class. Object literals are just as good.</p>\n<p>Mithril instantiates components for you. That wouldn‚Äôt be worth mentioning if not for the fact that when you need to pass something from parent component to a child component, you need to figure out how to do it the Mithril way, rather than just using javascript you already know.</p>\n<p>In code, the difference looks like this:</p>\n<p>Hyperdom:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Thing</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span>stuff<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>stuff <span class=\"token operator\">=</span> stuff\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">h</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Thing</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>stuff<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Mithril:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Thing</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">oninit</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">vnode</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// or any other lifecycle method</span>\n    <span class=\"token keyword\">const</span> stuff <span class=\"token operator\">=</span> vnode<span class=\"token punctuation\">.</span>attrs<span class=\"token punctuation\">.</span>stuff\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">m</span><span class=\"token punctuation\">(</span>Thing<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>stuff<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>On my toy project, that was merely a flavor difference, past the fact that I had to learn how to do this in Mithril.</p>\n<h2>Performance</h2>\n<p>Performance is a broad subject, but there is one aspect of it that I was particularly curious about - multiple DOM updates. Why is that interesting? For fast browser tests. Tests can click links and type into inputs extremely fast and if each of those events causes a DOM update, then it better be fast.</p>\n<p>To get an answer to this question, I made another <a href=\"https://github.com/artemave/render-performance-compare\">little project</a> that runs a simple test for the same app implemented in both frameworks. The test types in 4000 characters into an input. Input value is bound onto a div. The test is complete once all 4000 characters show up in that div.</p>\n<p>After running this test a few times, Mithril came out a winner, albeit by a small margin.</p>\n<p>I also couldn‚Äôt help but include React into the comparison and, on that particular test, it scores ten times slower then either Mithril or Hyperdom!</p>\n<h2>Conclusion</h2>\n<p>This is by no means an exhaustive comparison. But, surely, the only one that exists in the observable universe - so there you go ;)</p>\n<p>I haven‚Äôt encountered any killer features of Mithril over Hyperdom. So, as someone who is already familiar with Hyperdom, I‚Äôd stick to it. Having said that, bar some minor issues, Mithril looks solid. Something I‚Äôd chose over React any day.</p>","fields":{"slug":"/blog/mithril-vs-hyperdom/"},"frontmatter":{"date":"July 12, 2019","title":"Mithril vs Hyperdom","subtitles":null,"author":"Artem Avetisyan","short_description":"Frontend framework comparison","hidden":true}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/blog/mithril-vs-hyperdom/","prev":null,"next":null}}